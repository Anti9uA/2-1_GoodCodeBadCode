# 3장. 클래스 설계 : 모든 것과 연결되는 설계 기반

## 클래스 단위로 잘 동작하도록 설계하기

클래스는 **클래스 하나로도 잘 동작할 수 있게 설계**해야 합니다.
또한 복잡한 초기 설정을 하지 않아도 **곧바로 사용할 수 있게 만들어야 합니다.**
그리고 최소한의 조작 방법(메서드)만 외부에 제공해야 합니다.

**잘 만들어진 클래스**는 다음과 같은 두 가지로 구성됩니다.

- 인스턴스 변수
- 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드

이 둘 중 하나라도 빠지면 안됩니다. 다만, 목적에 따라 예외적으로 둘 중 하나가 빠져있는 구성이 좋을 때도 있습니다.

<img width="433" alt="image" src="https://github.com/sipe-team/2-1_GoodCodeBadCode/assets/46712693/2639fce0-8cd2-4f13-90df-4dd4c4fa736a">

그렇다면 왜 이런 구성을 지켜야 할까요?

**데이터 클래스**는 일반적으로 인스턴스 변수를 조작하는 로직이 다른 클래스에 구현되어 있습니다.
따라서 연관성을 알아채기 어려워 코드가 중복될 수 있고, 수정하다가 중복 코드 중 일부를 그대로 두는 일이 생길 수 있으며, 가독성을 낮춥니다.
또한 초기화 작업이나 유효성 검사도 다른 클래스에서 구현되어 있습니다.
그렇기 때문에 다른 클래스가 여러 가지 준비를 잘 해줘야만 잘 작동할 수 있습니다.
참고로, 이렇게 혼자서는 아무것도 할 수 없는 클래스를 **미성숙한 클래스**라고 합니다.

그럼 어떻게 해야 할까요?

다른 클래스에 맡기던 일을 데이터 클래스가 스스로 할 수 있게 설계하면 됩니다.

## 성숙한 클래스로 성장시키는 설계 기법

아래 데이터 클래스를 성숙한 클래스로 성장시키는 과정을 살펴보도록 하겠습니다.

```java
class Money {
    int amount; // 금액
    Currency currency; // 통화 단위
}
```

### 생성자로 확실하게 정상적인 값 설정하기

인스턴스 변수를 모두 **초기화**하는 데 필요한 매개변수들을 받는 생성자를 만듭니다.
이 때, 잘못된 값이 유입되지 못하게 **유효성 검사**를 생성자 내부에 정의합니다.

```java
class Money {
    int amount;
    Currency currency;
    
    Money(int amount, Currency currency) {
        // 유효성 검사
        if (amount < 0) {
            throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요.");
        }
        if (currency == null) {
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }
        
        // 인스턴스 변수 초기화
        this.amount = amount;
        this.currency = currency;
    }
}
```

참고로, 처리 범위를 벗어나는 조건을 메서드 가장 앞부분에서 확인하는 코드를 **가드(guard)** 라고 부릅니다.

### 계산 로직도 데이터를 가진 쪽에 구현하기

'데이터'와 '데이터를 조작하는 로직'이 분리되어 있는 구조를 **'응집도가 낮은 구조'** 라고 합니다.
응집도가 낮은 구조에서는 다음과 같은 문제가 발생할 수 있습니다.

- 코드를 이해하기 어렵다.
- 재사용이 힘들다.
- 유지보수가 쉽지 않다.
- 클래스 변화에 민감하다.

이러한 문제를 막기 위해 클래스 내부에 계산 로직을 구현하여 클래스를 성숙하게 만들어야 합니다.

```java
class Money {
    // 생략
    void add(int other) {
        amount += other;
    }
}
```

### 불변 변수로 만들어서 예상하지 못한 동작 막기

**불변 변수**는 값을 한 번 할당하면 다시는 바꿀 수 없는 변수입니다. 불변 변수로 만들려면 `final` 수식자를 사용합니다.

```java
class Money {
    final int amount;
    final Currency currency;
    
    Money(int amount, Currency currency) {
        // 생략
        this.amout = amount;
        this.currency = currency;
    }
}
```

이렇게 인스턴스 변수에 final 수식자를 붙여 불변 변수로 선언하면,
변수 선언 시점 또는 생성자 안에서만 값을 할당할 수 있으며 재할당할 수 없습니다.

### 변경하고 싶다면 새로운 인스턴스 만들기

불변 변수이기에 인스턴스 변수의 값 자체를 변경할 수 없습니다.
그렇다고 값을 변경할 수 없다는 의미는 아닙니다.
값을 변경하고 싶다면, **변경된 값을 가진 새로운 인스턴스를 만들어서 사용**하면 됩니다.

```java
class Money {
    // 생략
    Money add(int other) {
        int added = amount + other;
        return new Money(added, currency);
    }
}
```

이렇게 하면 불변을 유지하면서도 값을 변경할 수 있습니다.

### 메서드 매개변수와 지역 변수도 불변으로 만들기

메서드 매개변수와 지역 변수도 불변으로 만든다면, 중간에 값을 변경할 수 없기 때문에 좀 더 안전한 메서드 구조를 만들 수 있습니다.
~~자세한 내용은 4장에서 확인하실 수 있습니다.~~

```java
class Money {
    // 생략
    Money add(final int other) {
        final int added = amount + other;
        return new Money(added, currency);
    }
}
```

### 엉뚱한 값을 전달하지 않도록 하기

`int`나 `String`처럼 프로그래밍 언어가 표준적으로 제공하는 자료형인 **기본 자료형** 위주로 사용하면, 실수로 의미가 다른 값을 전달할 수 있습니다.
이렇게 엉뚱한 값이 전달되지 않도록 하려면, 현재 클래스의 자료형만 매개변수로 받을 수 있게 메서드를 변경하면 됩니다.
추가로 통화 단위가 다른 두 금액이 더해지는 상황을 막을 수 있도록 구현하였습니다.

```java
class Money {
    // 생략
    Money add(final Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }
        
        final int added = amount + other.amount;
        return new Money(added, currency);
    } 
}
```

### 의미 없는 메서드 추가하지 않기

시스템 사양에 필요하지 않는 메서드는 버그를 일으킬 수 있으므로 추가하지 않도록 합니다.

## 객체 지향을 활용한 설계 효과 검증

데이터 클래스를 성숙한 클래스로 변경한 결과는 다음과 같습니다.

<img width="226" alt="image" src="https://github.com/sipe-team/2-1_GoodCodeBadCode/assets/46712693/064f840a-b883-4f40-a1ae-d79a891aad2f">

```java
class Money {
    final int amount;
    final Currency currency;
    
    Money(int amount, Currency currency) {
        // 유효성 검사
        if (amount < 0) {
            throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요.");
        }
        if (currency == null) {
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }
        
        // 인스턴스 변수 초기화
        this.amount = amount;
        this.currency = currency;
    }

    Money add(final Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

다음 표를 통해 검증해보면 단단한 구조가 되었음을 확인할 수 있습니다.

| 검토 항목         | 검토 결과                                                                             |
|:--------------|:----------------------------------------------------------------------------------|
| 중복 코드         | 필요한 로직이 Money 클래스 내부에 모여 있으므로, 다른 클래스에 중복 코드가 작성될 일이 줄어듦                          |
| 수정 누락         | 중복코드가 발생하지 않으므로, 수정 시 누락이 발생할 일이 줄어듦                                              |
| 가독성 저하        | 필요한 로직이 모두 Money 클래스 내부에 모여 있어, 디버깅 또는 기능 변경 시 관련된 로직을 찾으러 돌아다니지 않아도 되므로 가독성이 높아짐 |
| 쓰레기 객체        | 생성자에서 인스턴스 변수의 값을 확정하므로, 초기화되지 않은 상태가 있을 수 없음                                     |
| 잘못된 값         | 잘못된 값을 막을 가드를 설치하고, 인스턴스 변수에 final 수식자를 붙여 불변으로 만들었으므로, 잘못된 값이 들어오지 않음            |
| 생각하지 못한 부수 효과 | final 수식자를 붙여 불변 변수로 만들었으므로, 부수 효과로부터 안전함                                         |
| 값 전달 실수       | 매개변수를 Money 자료형으로 바꿨으므로, 다른 자료형의 값을 실수로 넣었을 때 컴파일 오류가 발생함                         |

이처럼 인스턴스 변수 중심으로 인스턴스 변수가 잘못된 상태에 빠지지 않게 설계하면 됩니다.
**클래스 설계란 인스턴스 변수가 잘못된 상태에 빠지지 않게 하기 위한 구조를 만드는 것**이라고 해도 과언은 아닙니다.

Money 클래스처럼 로직이 한 곳에 모여 있는 구조는 **응집도가 높은 구조**라고 합니다. 또한, '데이터'와 '그 데이터를 조작하는 로직'을 하나의 클래스로 묶고, 필요한 절차만 외부에 공개하는 것을 **캡슐화**라고 합니다.


## 프로그램 구조의 문제 해결에 도움을 주는 디자인 패턴

프로그램의 구조를 개선하는 설계 방법을 **디자인 패턴(설계 패턴, design pattern)** 이라고 합니다.

| 디자인 패턴    | 효과                               |
|:----------|:---------------------------------|
| 완전 생성자    | 잘못된 상태로부터 보호함                    |
| 값 객체      | 특정한 값과 관련된 조직의 응집도를 높임           |
| 전략        | 조건 분기를 줄이고, 로직을 단순화함             |
| 정책        | 조건 분기를 단순화하고, 더 자유롭게 만듦          |
| 일급 컬렉션    | 값 객체의 일종으로 컬렉션과 관련된 로직의 응집도를 높임  |
| 스프라우트 클래스 | 기존 로직을 변경하지 않고, 안전하게 새로운 기능을 추가함 |

여러 디자인 패턴 중 Money 클래스에 적용한 것은 **완전 생성자**와 **값 객체** 입니다.
일반적으로 **'값 객체 + 완전 생성자'는 객체 지향 설계에서 폭넓게 사용되는 기법**이라고 할 수 있습니다.

### 완전 생성자

**완전 생성자**는 잘못된 상태로부터 클래스를 보호하기 위한 디자인 패턴입니다.
인스턴스 변수를 모두 초기화해야만 객체를 생성할 수 있게 매개변수를 가진 생성자를 만들며, 생성자 내부에서는 가드를 사용해 잘못된 값이 들어오지 않게 만드는 것이 완전 생성자입니다.

### 값 객체
**값 객체**란 값을 클래스(자료형)로 나타내는 디자인 패턴입니다.
값 객체러 만들어서 사용하면, 각각의 값과 로직을 응집도가 높은 구조로 만들 수 있습니다.

## 참고
- 도서 : 내 코드가 그렇게 이상한가요? (현재 스터디 진행 중인 책)
- <https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B2%B0%ED%95%A9%EB%8F%84-%EC%9D%91%EC%A7%91%EB%8F%84-%EC%9D%98%EB%AF%B8%EC%99%80-%EB%8B%A8%EA%B3%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC>

