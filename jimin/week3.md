## 4장. 불변 활용하기: 안정적으로 동작하게 만들기
### 재할당
변수에 값을 다시 할당하면서 **값의 의미가 바뀌게 된다**면, 버그를 만들어 낼 가능성이 높아진다.

따라서 변수 하나를 재활용하지 않고, 새로운 변수를 만들어 사용할 필요가 있다. 

**재할당 막기**
1. 불변 변수로 만들어서 재할당 막기
    * 재할당을 `final` 키워드를 이용해 기계적으로 막을 수 있다. 

2. 매개변수도 불변으로 만들기 
    * 매개변수 또한 메서드 내에서 재할당 가능하므로 `final`로 재할당을 막을 수 있다.

### 가변으로 인해 발생하는 의도하지 않은 영향

#### 가변 인스턴스 재사용

인스턴스를 재사용하였을때, **한쪽의 변경이 다른 한쪽에 영향**을 줄 수 있다. 따라서 재사용하지 않는 로직으로 변경해야한다.

#### 함수로 가변 인스턴스 조작
다른 스레드가 같은 변수를 변경시켜 제대로 동작하지 않을 수 있다. (부수효과)

예상치 못한 동작을 막으려면, 다음 항목을 만족하도록 설계하는 것이 좋다.

1. 데이터는 매개변수로 받는다
2. 상태를 변경하지 않는다
3. 값은 함수의 리턴 값으로 돌려준다

위 항목을 만족하면서 코드를 작성하면 다음과 같다.

```java
class AttackPower {
    static final int MIN = 0;
    final int value; // 불변화

    AttackPower(final int value) {
        if (value < MIN) {
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    Attack reinforce(final AttackPower increment) {
        return new AttackPower(this.value + increment.value); //함수의 리턴 값으로 새로운 인스턴스 생성 
    }

    Attack disable() {
        return new Attack(MIN);
    }
}
```

### 불변과 가변은 어떻게 다루어야 할까
1. 기본적으로 불변으로
2. 가변으로 설계해야 하는 경우
    * 불변은 인스턴스를 매번 새로 생성하므로, 성능에 영향을 끼칠 수 있다. **성능에 민감한 경우**라면 가변으로 설계할 수 있다.
    * **스코프가 국소**적인 경우 가변으로 해도 좋다. (ex. 반복문 카운터 등 반복 처리 스코프에만 사용되는 지역변수)
3. 상태를 변경하는 메서드 설계
    * 만약 인스턴스 변수를 가변으로 만들었다면 올바른 상태로만 변경하도록 잘 설계해야한다.
      ```java
       // 음수가 될 수 없도록 설계
        void damage(final int damageAmount) {
            final int nextAmount = amount - damageAmount;
            amount = Math.max(MIN, nextAmount);
        }
      ```
4. 코드 외부와 데이터 교환은 국소화
    * 파일이나 DB와 같이 코드 외부에 있는 상태라면 코드 내부에서 외부 동작을 제어할 수 없으므로 국소화하는 것이 좋다.
    * 레포지토리 패턴처럼 코드 외부와 데이터 교환을 국소화하는 테크닉을 사용할 수 있다.


