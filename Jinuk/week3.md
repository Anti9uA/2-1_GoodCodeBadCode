# 4. 불변 활용하기: 안정적으로 동작하게 만들기

- 재할당
  - 변수에 값을 다시 할당하는 것
  - 파괴적 할당이라고도 함
  - 중간에 의미가 바뀌면 읽는 사람은 헷갈리게 됨, 버그 생성확률 up
  - 새롭게 변수를 만들어서 사용하면 재할당을 피할 수 있음

  - 불변 변수로 만들어서 재할당 막기
    - final 수식자 붙이기
    - 컴파일 단계에서 에러 발생
  - 매개변수도 불변으로 만들기
    - 매개변수에도 final을 붙여서 변경되지 않도록 만들기

- 가변으로 인해 발생하는 의도하지 않은 영향
  - 사례1. 가변 인스턴스 재사용
    - 동일한 인스턴스를 재사용하면서, 다른 클래스에 영향을 주는 사례
    - 인스턴스를 재사용하지 못하게 만들어 줘야 함
  - 사례2. 함수로 가변 인스턴스 조작
    - 다른 스레드에서 같은 인스턴스를 사용하면서, 값이 변동되는 사례
    - 외부 상태를 변경하는 부수 효과 발생

  - 부수 효과
    - 함수 외부의 상태를 변경하게 되는 것
    - 작업 실행 순서에 의존하게 되면, 결과 예측이 어렵고 유지보수하기 힘듬

  - 함수의 영향 범위 한정하기
    - 데이터는 매개변수로 받기
    - 상태를 변경하지 않기
    - 값은 함수의 리턴 값으로 돌려주기

  - 불변으로 만들어서 예기치 못한 동작 막기
    - 기능 변경 때 의도하지 않은 부수 효과가 있는 함수가 만들어져, 예상하지 못한 동작을 일으킬 가능성이 항상 존재
    - 불변 변수 사용을 통해 가능성 원천 봉쇄

- 불변과 가변은 어떻게 다루어야 할까
  - 기본적으로 불변으로
    - 기본적으로는 불변으로 설계하는 것이 좋음
    - 자바는 final, 코틀린/스칼라는 val(불변)과 var(가변) 사용
    - JS는 const 사용
    - 러스트에서는 불변이 디폴트

  - 가변으로 설계해야 하는 경우
    - 성능이 중요한 경우
    - 스코프가 국소적인 경우

  - 상태를 변경하는 메서드 설계
    - 뮤테이터라고 함
    - 가변일 때는 반드시 올바른 상태로만 변경하도록 구현

  - 코드 외부와 데이터 교환은 국소화하기
    - 외부 상태에 의존하는 경우, 코드에서는 제어 불가
    - 동작 예측이 힘들어지므로 문제가 발생할 가능성이 커짐
    - 리포지터리 패턴 등을 통해 데이터 교환 국소화
